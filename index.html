<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Servo GUI (Web Serial)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; max-width:900px; margin:20px auto; }
    h1 { font-size:20px }
    .row { display:flex; align-items:center; gap:12px; margin:8px 0; }
    .slider { flex:1; }
    .val { min-width:48px; text-align:center; }
    button { padding:8px 12px; margin-left:6px; }
    #log { height:120px; overflow:auto; border:1px solid #ddd; padding:6px; background:#fafafa; font-size:13px }
    .controls { display:flex; gap:8px; margin-top:10px; flex-wrap:wrap; }
  </style>
</head>
<body>
  <h1>Contrôle servos — Interface Web (WebSerial)</h1>
  <p>Connecte-toi au port série, puis utilise les sliders. Les commandes envoyées suivent le format <code>S{index}:{angle}</code> (ex. <code>S0:90</code>) ou <code>ALL:{angle}</code> ou <code>CYCLE:ON/OFF</code>.</p>

  <div class="controls">
    <button id="btnConnect">Connecter</button>
    <button id="btnDisconnect" disabled>Déconnecter</button>
    <button id="btnCycleOn" disabled>Démarrer cycle</button>
    <button id="btnCycleOff" disabled>Arrêter cycle</button>
    <button id="btnAll45" disabled>Tous 45°</button>
  </div>

  <div id="sliders" style="margin-top:14px">
    <!-- sliders générés par JS -->
  </div>

  <h3>Log série</h3>
  <div id="log"></div>

<script>
  const NB_SERVOS = 5;
  let port = null;
  let writer = null;
  let reader = null;
  let keepReading = false;
  let lastSent = Array(NB_SERVOS).fill(-1);
  let sendThrottleTimer = null;

  const logEl = document.getElementById('log');

  function log(s){
    const line = document.createElement('div');
    line.textContent = (new Date()).toLocaleTimeString() + '  —  ' + s;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  }

  // création des sliders
  const slidersDiv = document.getElementById('sliders');
  for (let i=0;i<NB_SERVOS;i++){
    const row = document.createElement('div');
    row.className = 'row';
    const label = document.createElement('div');
    label.textContent = 'Servo ' + i;
    label.style.width = '70px';
    const input = document.createElement('input');
    input.type = 'range';
    input.min = 0;
    input.max = 180;
    input.value = 90;
    input.className = 'slider';
    input.dataset.index = i;
    const val = document.createElement('div');
    val.className = 'val';
    val.textContent = input.value;

    // envoi throttlé - on envoie la valeur si l'utilisateur arrête de bouger (150ms) ou si elle change signif.
    input.addEventListener('input', (e)=>{
      val.textContent = e.target.value;
      scheduleSend(e.target.dataset.index, e.target.value);
    });

    row.appendChild(label);
    row.appendChild(input);
    row.appendChild(val);
    slidersDiv.appendChild(row);
  }

  function scheduleSend(index, angle){
    // throttle pour éviter d'envoyer trop rapidement lors du "slide"
    lastSent[index] = angle;
    if (sendThrottleTimer) clearTimeout(sendThrottleTimer);
    sendThrottleTimer = setTimeout(()=> {
      // envoie les valeurs qui ont changé
      for (let i=0;i<NB_SERVOS;i++){
        if (lastSent[i] !== -1){
          sendCommand(`S${i}:${lastSent[i]}\n`);
          lastSent[i] = -1;
        }
      }
    }, 120); // 120 ms après le dernier mouvement
  }

  async function connect() {
    try {
      // demande de port
      port = await navigator.serial.requestPort();
      await port.open({ baudRate: 9600 });
      log('Port série ouvert (baud 9600). Attente reset Arduino...');
      // petit délai pour laisser l'Arduino redémarrer (si besoin)
      await new Promise(r => setTimeout(r, 1500));

      writer = port.writable.getWriter();
      // start reading loop
      keepReading = true;
      readLoop();

      // UI
      document.getElementById('btnConnect').disabled = true;
      document.getElementById('btnDisconnect').disabled = false;
      document.getElementById('btnCycleOn').disabled = false;
      document.getElementById('btnCycleOff').disabled = false;
      document.getElementById('btnAll45').disabled = false;
      log('Prêt. Envoie des valeurs actuelles sliders...');
      // envoyer l'état actuel des sliders pour synchroniser
      const inputs = document.querySelectorAll('input[type=range]');
      inputs.forEach((inp, idx)=> {
        sendCommand(`S${idx}:${inp.value}\n`);
      });
    } catch (e) {
      console.error(e);
      log('Erreur connexion: ' + e);
    }
  }

  async function disconnect(){
    keepReading = false;
    if (reader) {
      try { await reader.cancel(); } catch(e){}
      reader = null;
    }
    if (writer) {
      writer.releaseLock();
      writer = null;
    }
    if (port) {
      await port.close();
      port = null;
    }
    document.getElementById('btnConnect').disabled = false;
    document.getElementById('btnDisconnect').disabled = true;
    document.getElementById('btnCycleOn').disabled = true;
    document.getElementById('btnCycleOff').disabled = true;
    document.getElementById('btnAll45').disabled = true;
    log('Déconnecté.');
  }

  async function readLoop(){
    const textDecoder = new TextDecoderStream();
    const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
    reader = textDecoder.readable.getReader();

    try {
      while (keepReading) {
        const { value, done } = await reader.read();
        if (done) break;
        if (value) {
          value.split(/\r?\n/).forEach(line=>{
            if (line.trim().length) log('-> ' + line.trim());
          });
        }
      }
    } catch (e) {
      console.error('readLoop error', e);
      log('Erreur lecture série: ' + e);
    } finally {
      if (reader) reader.releaseLock();
    }
  }

  async function sendCommand(str){
    if (!port || !writer) {
      log('Port non connecté — commande non envoyée: ' + str.trim());
      return;
    }
    try {
      // encode et envoie
      const data = new TextEncoder().encode(str);
      await writer.write(data);
      log('<- ' + str.trim());
    } catch (e) {
      console.error(e);
      log('Erreur envoi: ' + e);
    }
  }

  // boutons
  document.getElementById('btnConnect').addEventListener('click', connect);
  document.getElementById('btnDisconnect').addEventListener('click', disconnect);
  document.getElementById('btnCycleOn').addEventListener('click', ()=> sendCommand('CYCLE:ON\n'));
  document.getElementById('btnCycleOff').addEventListener('click', ()=> sendCommand('CYCLE:OFF\n'));
  document.getElementById('btnAll45').addEventListener('click', ()=> {
    // ajuste sliders visuellement aussi
    document.querySelectorAll('input[type=range]').forEach((r)=> { r.value = 45; r.nextSibling.textContent = '45'; });
    sendCommand('ALL:45\n');
  });

  // clean up on page close
  window.addEventListener('beforeunload', async (e) => {
    if (port) {
      try { await disconnect(); } catch(e) {}
    }
  });

</script>
</body>
</html>
